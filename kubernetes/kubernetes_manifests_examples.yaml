# =============================================================================
# EXEMPLES DE MANIFESTES KUBERNETES
# Fichier : kubernetes_manifests_examples.yaml
# 
# Ces manifestes doivent être appliqués APRÈS le déploiement du cluster GKE
# via Terraform. Ils configurent l'application Task Manager selon les
# exigences des Cours 5 et 7.
#
# Utilisation :
#   kubectl apply -f kubernetes_manifests_examples.yaml
# =============================================================================

---
# =============================================================================
# 1. DEPLOYMENT - Cours 5, Section 2.2
# Gère les ReplicaSets et les Pods de l'application Task Manager
# Supporte les rolling updates et rollbacks
# =============================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: task-manager
  labels:
    app: task-manager
spec:
  replicas: 2  # Nombre initial de replicas (sera géré par le HPA)
  selector:
    matchLabels:
      app: task-manager
  template:
    metadata:
      labels:
        app: task-manager
    spec:
      containers:
      - name: task-manager
        image: gcr.io/PROJECT_ID/task-manager:latest  # Remplacez PROJECT_ID
        ports:
        - containerPort: 8080
          name: http
        
        # Variables d'environnement pour la connexion à la base de données
        env:
        - name: DB_HOST
          value: "10.x.x.x"  # IP privée de votre instance Cloud SQL
        - name: DB_NAME
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: database
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: password
        
        # Ressources (importantes pour le HPA)
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi
        
        # Liveness Probe - Cours 7, Section 6
        # Vérifie si le pod est en vie, redémarre si nécessaire
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        
        # Readiness Probe - Cours 7, Section 6
        # Vérifie si le pod est prêt à recevoir du trafic
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 2

---
# =============================================================================
# 2. SERVICE - LoadBalancer (Cours 7, Section 2.2, Option 1)
# Expose l'application à internet via un Load Balancer GCP
# Fournit un endpoint stable malgré les pods éphémères
# =============================================================================
apiVersion: v1
kind: Service
metadata:
  name: task-manager-service
  annotations:
    # Annotations spécifiques à GCP pour le Load Balancer
    cloud.google.com/load-balancer-type: "External"
spec:
  type: LoadBalancer
  selector:
    app: task-manager  # Sélectionne les pods avec ce label
  ports:
    - name: http
      port: 80        # Port exposé par le Load Balancer
      targetPort: 8080  # Port du conteneur
      protocol: TCP
  # Pour HTTPS, vous devrez configurer un Ingress avec des certificats SSL

---
# =============================================================================
# 3. HORIZONTAL POD AUTOSCALER (Cours 7, Section 4.1) - OBLIGATOIRE
# Scale automatiquement les pods en fonction de l'utilisation CPU
# Fonctionne en tandem avec le Cluster Autoscaler pour le scaling complet
# =============================================================================
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: task-manager-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: task-manager
  
  # Configuration du scaling
  minReplicas: 1   # Minimum de pods (économise les ressources)
  maxReplicas: 6   # Maximum de pods
  
  # Métriques pour le scaling
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70  # Scale up si CPU > 70%
    
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80  # Scale up si mémoire > 80%
  
  # Comportement du scaling
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60   # Attend 60s avant de scale up
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
      - type: Pods
        value: 2
        periodSeconds: 60
    scaleDown:
      stabilizationWindowSeconds: 300  # Attend 5min avant de scale down
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60

---
# =============================================================================
# 4. SECRET - Credentials de la base de données
# Stocke de manière sécurisée les informations de connexion
# =============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
stringData:
  database: "taskmanager"
  username: "admin"
  password: "CHANGEME"  # ⚠️ À remplacer par le vrai mot de passe

---
# =============================================================================
# 5. INGRESS (Alternative au Service LoadBalancer) - Optionnel
# Permet d'avoir HTTPS, routing avancé, et SSL certificates
# Cours 7, Section 2.2, Option 1 (plus avancé)
# =============================================================================
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: task-manager-ingress
  annotations:
    # Annotations pour GCP Load Balancer
    kubernetes.io/ingress.class: "gce"
    # Pour SSL automatique avec Google-managed certificates
    networking.gke.io/managed-certificates: "task-manager-cert"
    # Force HTTPS
    kubernetes.io/ingress.allow-http: "false"
spec:
  rules:
  - host: taskmanager.example.com  # Remplacez par votre domaine
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: task-manager-service
            port:
              number: 80

---
# =============================================================================
# 6. MANAGED CERTIFICATE (pour HTTPS) - Optionnel
# Certificat SSL géré par Google pour votre domaine
# Cours 7, Section 6 - Enable HTTPS
# =============================================================================
apiVersion: networking.gke.io/v1
kind: ManagedCertificate
metadata:
  name: task-manager-cert
spec:
  domains:
    - taskmanager.example.com  # Remplacez par votre domaine

---
# =============================================================================
# 7. NETWORK POLICY (Cours 5, Section 2.3) - Sécurité
# Définit les règles de communication entre pods
# =============================================================================
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: task-manager-network-policy
spec:
  podSelector:
    matchLabels:
      app: task-manager
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector: {}  # Autorise le trafic de tous les pods du namespace
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector: {}  # Autorise le trafic vers tous les pods
  - to:  # Autorise l'accès à la base de données
    - namespaceSelector: {}
    ports:
    - protocol: TCP
      port: 5432  # Port PostgreSQL

---
# =============================================================================
# 8. POD DISRUPTION BUDGET - Cours 5, Section 2.2
# Garantit la disponibilité pendant les maintenances
# =============================================================================
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: task-manager-pdb
spec:
  minAvailable: 1  # Toujours garder au moins 1 pod disponible
  selector:
    matchLabels:
      app: task-manager

# =============================================================================
# INSTRUCTIONS DE DÉPLOIEMENT
# =============================================================================
#
# 1. Déployez d'abord le cluster avec Terraform :
#    terraform apply -var-file=envs/dev.tfvars
#
# 2. Configurez kubectl :
#    gcloud container clusters get-credentials <cluster-name> --region <region> --project <project-id>
#
# 3. Créez le secret avec les vraies credentials :
#    kubectl create secret generic db-credentials \
#      --from-literal=database=taskmanager \
#      --from-literal=username=admin \
#      --from-literal=password=VOTRE_MOT_DE_PASSE
#
# 4. Déployez les manifestes :
#    kubectl apply -f kubernetes_manifests_examples.yaml
#
# 5. Vérifiez le déploiement :
#    kubectl get pods
#    kubectl get svc
#    kubectl get hpa
#
# 6. Obtenez l'IP externe du Load Balancer :
#    kubectl get svc task-manager-service
#
# 7. Testez le scaling :
#    kubectl run -i --tty load-generator --rm --image=busybox --restart=Never -- /bin/sh
#    # Dans le pod : while true; do wget -q -O- http://task-manager-service; done
#
# 8. Observez le scaling :
#    kubectl get hpa -w
#    kubectl get pods -w
#
# =============================================================================


